<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/e02e1e7f.271c5708.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/e02e1e7f.271c5708.chunk.css"/><link rel="preload" href="/_next/static/NneAG4sKnpsuykkV4vDeb/pages/p/%5Bfilename%5D.js" as="script"/><link rel="preload" href="/_next/static/NneAG4sKnpsuykkV4vDeb/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-9369c5c69dbf6d4912cb.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.5fcc7199ef0beb206d2f.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.3c5d97082f0a27bb013b.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-0fe46e94a529f955381f.js" as="script"/><link rel="preload" href="/_next/static/chunks/e02e1e7f.37da1e6c94fa5227f4d3.js" as="script"/><link rel="preload" href="/_next/static/chunks/c32e8f60042697b88c7a7eeabb52ff7d578ec089.c62b0744126db24a167b.js" as="script"/></head><body><div id="__next"><div class="_244SQdSGVWtQZCB8PpVUGN"><div><a style="margin-right:15px" href="/">Home</a><a style="margin-right:15px" href="/about/">About</a></div><div class="_3vdMid2AAz1IImw9S0kNnB"><h1>Argon2, Memory-Hard Hash Function</h1><blockquote><p>文章主要基于 Argon2 的论文和其他一些资料，很可能有理解和表达错误的地方需要指正</p></blockquote><h2>Password</h2><p>Password 是 Web 服务主要的认证方式之一</p><p>Password 一般以 Hash 后的形式存储在数据库中。这些数据库如果被拖库，使用 Dictionary Attack 可以轻松破解，因为他们的墒很低。相同的密码会被不同的用户使用或同一个用户在不同系统中使用</p><p>为了解决这个问题，设计者在密码 Hash 的过程里加入了 <em>salt</em></p><blockquote><p><strong>Dictionary Attack</strong>
一个字典文件，储存了单词、短语、常用密码和他们 hash 后结果。将密码与 hash 结果对比，就能破解</p><p><strong>Brute Force Attack</strong>
尝试每一个给顶长度下的字符组合，效率很低</p></blockquote><p>加盐已经可以解决大部分问题，但无法阻止 Brute Force Attack，借助 GPU、FPGA、ASIC 等定制硬件可以非常低成本的进行 Hash 计算。此外，如果 salt 和 password 被一起被拖库（甚至代码），会使得破解成本更加低。</p><p>这里核心的问题是，Hash 方法使用的是无内存计算的，而 GPU、ASIC 等硬件可以让无内存计算变得非常高效。但是，当一个 Hash 方法需要用到一大块内存去计算的时候，这些硬件就会束手无策。所以 memory-hard hash function 开始被设计和使用。</p><p>memory-hard hash function 也可以被用在加密货币的工作量证明中，用来压制 GPU 和 ASIC 在加密货币中的滥用。例如 scrypt 被用作莱特币的工作量证明算法。</p><h2>现有的算法的问题</h2><p>要解决密码安全性的问题，一个简单的方法是使用密钥 Hash，例如 HMAC。但是如果设计者更喜欢不是用密钥以防止密钥生成、存储、更新带来的额外问题，那他可以使用 PBKDF2、bcrypt 和 scrpyt。</p><p>这几个算法里只有 scrypt 是以高内存为目标的。但是可以通过 time-space tradeoff 将内存消耗转迁到计算资源消耗上。（scrypt 起初的设计是为了节省 CPU 计算资源，用内存换了计算时间。不是专门为了密码学设计的）</p><p>设计一个 memory-hard hash function是很难的问题。早在 80 年代初期就已经出现这类算法，但实际上都可以被 time-space tradeoff 绕过。攻击者可以将 memory 消耗转换为 time 消耗，然后在高速硬件上使用低内存进行破解。这意味着，攻击者仍然可以实现特制的硬件来破解，即使付出一些额外的代价。</p><h2>Argon2</h2><p>Argon2 是 PHC（Password Hashing Competition）的冠军，利用大量内存和大量计算资源进行 Hash 计算。提供三个版本：</p><ul><li>Argon2d：更快，使用 data-dependent 的内存访问方式，data 是需要 Hash 的 password 和 salt。适合加密货币和不会收到 side-channel timing 攻击的应用</li><li>Argon2i：使用 data-independent 的内存访问方式，更适合密码哈希等。他比 Argon2d 慢，因为它需要更多次内存计算（passes）来保护免受 tradeoff 的攻击</li><li>Argon2id：是 Argon2i 和 Argon2d 的混合版本，第一次计算用 Argon2i，后续的计算用 Argon2d。如果没有特定的理由，推荐使用 Argon2id。</li></ul><h2>memory-hard hash function 的定义</h2><p>使用 time-area 复杂度衡量，面积指的是电路板上的远件个数，增加元件个数可以减少运算的时间，所以可以使用面积乘以时间作为复合评价尺度。</p><p>我们将攻击者使用的 ASIC 上内存大小对应为面积 A，运行时长为 T。</p><p>Hash 算法（H）的目标是令 A*T 最大化</p><p>假设攻击者想降低内存的使用，只使用 αM 的内存来计算 H（α &lt; 1）</p><p>对 H 使用 time-space tradeoff 的方法，它需要多花  C(α) 倍计算成本，而它的计算时间至少增加了 D(α) 倍。因此，在 time-area 乘积里，可能的最大增益 ε 为</p><p>$$ε<em>{max}=\max</em>α{\frac 1{αD(α)}}$$</p><p>拿前后两个 AT 乘积相比，定义为增益。攻击者的目的是要让分母尽可能的小，也就是 ε 尽可能的大。因此，最大收益就是上面列出的公式</p><p>一个算法被称为 memory-hard hash function 需要满足</p><p>D(α) &gt; 1/α，α 趋近于 0</p><p>只有这样，在攻击者减少内存的时候，最大收益 ε &lt; 1，也就是说减少内存时的 AT 复杂度不会降低。</p><p>除此之外，AT 值还会受到以下几个因素影响：</p><ul><li>计算资源因为内存减少而产生的惩罚 C(α) 可能会显著增加面积 A</li><li>如果 tradeoff 需要显著依赖计算资源之间的通信，那内存带宽的限制会对运行时间增加额外的限制</li></ul><h2>Argon2 的实现</h2><h3>输入</h3><p><strong>Primary inputs</strong> 是 message P 和 nonce S，代表密码和盐</p><p><strong>Secondary inputs</strong> 有</p><ul><li>并行程度 p</li><li>Tag length τ</li><li>内存大小 m kilobytes</li><li>迭代次数 t，用于调节运行时间，与内存大小独立</li><li>version number v</li><li>secret value K，默认没有 key</li><li>associated data X</li><li>Type y of Argon2, 0 for Argon2d, 1 for Argon2i, 2 for Argon2id</li></ul><h3>运算</h3><p>首先，给 P 和 S 做哈希，所有其他参数也被加入，变量 P、S、K、X 的长度被放置在他们前面。</p><p>H 是 Blake2b</p><p>$$H_0=H(p,τ,m,t,v,y,\langle P \rangle,P,\langle S \rangle,S,\langle K \rangle,K,\langle X \rangle,X)$$</p><p>然后 Argon2 用 m&#x27; 个block 填满内存</p><p>m&#x27; = m/4p 向下取整后 * 4p</p><p>为了方便调整并行线程数 p，内存组织以 B<a href="">i</a> 形式的 matrix 存储。有 p 行，q = m&#x27;/p 列。我们用以下形式，表示第 t 个 pass 里的 block</p><p>$$B^t<a href="">i</a>,t&gt;0$$</p><p>Block 的计算规则：</p><p><img alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/957c983c-74e8-4a18-8b08-7f41b2856e55/Untitled.png" src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/957c983c-74e8-4a18-8b08-7f41b2856e55/Untitled.png"/></p><p>其中，</p><ul><li>block index <a href="">i&#x27;</a> 根据使用的 Argon2d 或 Argon2i 而不同，结果可能是除了当前 slice 里的其他所有 block（下面图上跨 lane 的那几个虚线）</li><li>G 是排列组合函数，基于 Blake2b 的 round function 改进而来</li><li>H&#x27; 是长度可变的、在 H 的基础上实现的哈希函数</li></ul><p>如果 t&gt;1, 我们需要重复处理过程，我们用新的 block XOR 老的 block 得出</p><p><img alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e425bb22-5ab5-41bb-8260-085b2d771bb8/Untitled.png" src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e425bb22-5ab5-41bb-8260-085b2d771bb8/Untitled.png"/></p><p>当我们完成 t 次迭代后，我们计算最终的 block B_final，为最后一列所有值的异或</p><p><img alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a6e327b6-1b01-47f9-97bb-772c69737134/Untitled.png" src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a6e327b6-1b01-47f9-97bb-772c69737134/Untitled.png"/></p><p>最后，对 B_final 运算 H‘ 函数，完成最终的输出 Tag</p><p><img alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e6501409-72ff-495e-b9ee-da18d0c8e9d8/Untitled.png" src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e6501409-72ff-495e-b9ee-da18d0c8e9d8/Untitled.png"/></p><h2>Features</h2><ul><li>性能。Argon2 填充内存的速度非常快，从而增加了 AT 里的 A。Argon2i 对每个 byte 稳定占用 2 个 CPU cycles，Argon2d 就快 3 倍。</li><li>Tradeoff 抵御能力。默认 passes 配置下（Argon2d 为 1，Argon2i 为 3），ASIC 设备在减少至 α =1/4 或更少内存的时候，无法减少 time-area 复杂度。如果把 pass 数量提高，时间惩罚会更高。</li><li>可扩展性。Argon2 可以同时在时间和内存两个维度扩展，两者互相独立，保证始终能在一定数量的时间内填满一定数量的内存。</li><li>并行。Argon2 最多可以使用 2^24 个并发线程。在实验中，8 个线程就已经消耗完了所有的计算资源和带宽。</li><li>GPU/FPGA/ASIC-unfriendly。Argon2 对 x86 做了高度优化，所以在定制硬件下运行既不会更快也不会更便宜。</li><li>支持额外的输入。除了 message 和 nonce，类似 secret key，环境变量，用户数据等内容也可以被输入作为参数</li></ul><h2>安全性分析</h2><h3>Tradeoff attack</h3><p>结论是，data-dependent one-pass 的情况得下，攻击者可以在降低内存 3 倍的情况下，保持 time-area 复杂度不变。具体的表</p><p><img alt="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/328b20be-664f-49f6-84b0-e0aae3485a3b/Untitled.png" src="https://s3-us-west-2.amazonaws.com/secure.notion-static.com/328b20be-664f-49f6-84b0-e0aae3485a3b/Untitled.png"/></p><p>上面已经说过，D(α) &gt; 1/α，α 趋近于 0</p><p>在论文发布后，有两次公开的对 Argon2i 的破解。作者发布了更新版本，并做了 summary</p><ul><li>针对 1- 和 2-pass Argon2i(v1.3) 可以减少 time-area 复杂度至 α = 1/5</li><li>针对 t-pass(t&gt;2) 的 Argon2i，time-area 复杂度可以减少至 α = 1/3</li><li>针对 t-pass Argon2d，time-area 复杂度可以减少至 α = 1/1.33</li></ul><p>论文里还有更多针对内存优化攻击、迭代次数压缩攻击和通用攻击的具体分析，这里不展开了</p><p>更多的细节和内容去读代码和论文吧</p><h3>References</h3><ul><li><a href="https://github.com/P-H-C/phc-winner-argon2/blob/master/argon2-specs.pdf">https://github.com/P-H-C/phc-winner-argon2/blob/master/argon2-specs.pdf</a></li><li><a href="https://github.com/P-H-C/phc-winner-argon2">https://github.com/P-H-C/phc-winner-argon2</a></li><li><a href="https://crackstation.net/hashing-security.htm">https://crackstation.net/hashing-security.htm</a></li><li><a href="https://honest.engineering/posts/hash-functions-survival-guide?utm_source=ponyfoo+weekly&amp;utm_medium=email&amp;utm_campaign=138">https://honest.engineering/posts/hash-functions-survival-guide</a></li><li><a href="https://en.wikipedia.org/wiki/Argon2">https://en.wikipedia.org/wiki/Argon2</a></li><li><a href="https://en.wikipedia.org/wiki/Scrypt">https://en.wikipedia.org/wiki/Scrypt</a></li></ul></div></div></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"content":"# Argon2, Memory-Hard Hash Function\n\n\u003e 文章主要基于 Argon2 的论文和其他一些资料，很可能有理解和表达错误的地方需要指正\n\n## Password\n\nPassword 是 Web 服务主要的认证方式之一\n\nPassword 一般以 Hash 后的形式存储在数据库中。这些数据库如果被拖库，使用 Dictionary Attack 可以轻松破解，因为他们的墒很低。相同的密码会被不同的用户使用或同一个用户在不同系统中使用\n\n为了解决这个问题，设计者在密码 Hash 的过程里加入了 *salt*\n\n\u003e **Dictionary Attack**\n一个字典文件，储存了单词、短语、常用密码和他们 hash 后结果。将密码与 hash 结果对比，就能破解\n\n\u003e **Brute Force Attack**\n尝试每一个给顶长度下的字符组合，效率很低\n\n加盐已经可以解决大部分问题，但无法阻止 Brute Force Attack，借助 GPU、FPGA、ASIC 等定制硬件可以非常低成本的进行 Hash 计算。此外，如果 salt 和 password 被一起被拖库（甚至代码），会使得破解成本更加低。\n\n这里核心的问题是，Hash 方法使用的是无内存计算的，而 GPU、ASIC 等硬件可以让无内存计算变得非常高效。但是，当一个 Hash 方法需要用到一大块内存去计算的时候，这些硬件就会束手无策。所以 memory-hard hash function 开始被设计和使用。\n\nmemory-hard hash function 也可以被用在加密货币的工作量证明中，用来压制 GPU 和 ASIC 在加密货币中的滥用。例如 scrypt 被用作莱特币的工作量证明算法。\n\n## 现有的算法的问题\n\n要解决密码安全性的问题，一个简单的方法是使用密钥 Hash，例如 HMAC。但是如果设计者更喜欢不是用密钥以防止密钥生成、存储、更新带来的额外问题，那他可以使用 PBKDF2、bcrypt 和 scrpyt。\n\n这几个算法里只有 scrypt 是以高内存为目标的。但是可以通过 time-space tradeoff 将内存消耗转迁到计算资源消耗上。（scrypt 起初的设计是为了节省 CPU 计算资源，用内存换了计算时间。不是专门为了密码学设计的）\n\n设计一个 memory-hard hash function是很难的问题。早在 80 年代初期就已经出现这类算法，但实际上都可以被 time-space tradeoff 绕过。攻击者可以将 memory 消耗转换为 time 消耗，然后在高速硬件上使用低内存进行破解。这意味着，攻击者仍然可以实现特制的硬件来破解，即使付出一些额外的代价。\n\n## Argon2\n\nArgon2 是 PHC（Password Hashing Competition）的冠军，利用大量内存和大量计算资源进行 Hash 计算。提供三个版本：\n\n- Argon2d：更快，使用 data-dependent 的内存访问方式，data 是需要 Hash 的 password 和 salt。适合加密货币和不会收到 side-channel timing 攻击的应用\n- Argon2i：使用 data-independent 的内存访问方式，更适合密码哈希等。他比 Argon2d 慢，因为它需要更多次内存计算（passes）来保护免受 tradeoff 的攻击\n- Argon2id：是 Argon2i 和 Argon2d 的混合版本，第一次计算用 Argon2i，后续的计算用 Argon2d。如果没有特定的理由，推荐使用 Argon2id。\n\n## memory-hard hash function 的定义\n\n使用 time-area 复杂度衡量，面积指的是电路板上的远件个数，增加元件个数可以减少运算的时间，所以可以使用面积乘以时间作为复合评价尺度。\n\n我们将攻击者使用的 ASIC 上内存大小对应为面积 A，运行时长为 T。\n\nHash 算法（H）的目标是令 A*T 最大化\n\n假设攻击者想降低内存的使用，只使用 αM 的内存来计算 H（α \u003c 1）\n\n对 H 使用 time-space tradeoff 的方法，它需要多花  C(α) 倍计算成本，而它的计算时间至少增加了 D(α) 倍。因此，在 time-area 乘积里，可能的最大增益 ε 为\n\n$$ε_{max}=\\max_α{\\frac 1{αD(α)}}$$\n\n拿前后两个 AT 乘积相比，定义为增益。攻击者的目的是要让分母尽可能的小，也就是 ε 尽可能的大。因此，最大收益就是上面列出的公式\n\n一个算法被称为 memory-hard hash function 需要满足\n\nD(α) \u003e 1/α，α 趋近于 0\n\n只有这样，在攻击者减少内存的时候，最大收益 ε \u003c 1，也就是说减少内存时的 AT 复杂度不会降低。\n\n除此之外，AT 值还会受到以下几个因素影响：\n\n- 计算资源因为内存减少而产生的惩罚 C(α) 可能会显著增加面积 A\n- 如果 tradeoff 需要显著依赖计算资源之间的通信，那内存带宽的限制会对运行时间增加额外的限制\n\n## Argon2 的实现\n\n### 输入\n\n**Primary inputs** 是 message P 和 nonce S，代表密码和盐\n\n**Secondary inputs** 有\n\n- 并行程度 p\n- Tag length τ\n- 内存大小 m kilobytes\n- 迭代次数 t，用于调节运行时间，与内存大小独立\n- version number v\n- secret value K，默认没有 key\n- associated data X\n- Type y of Argon2, 0 for Argon2d, 1 for Argon2i, 2 for Argon2id\n\n### 运算\n\n首先，给 P 和 S 做哈希，所有其他参数也被加入，变量 P、S、K、X 的长度被放置在他们前面。\n\nH 是 Blake2b\n\n$$H_0=H(p,τ,m,t,v,y,\\langle P \\rangle,P,\\langle S \\rangle,S,\\langle K \\rangle,K,\\langle X \\rangle,X)$$\n\n然后 Argon2 用 m' 个block 填满内存\n\nm' = m/4p 向下取整后 * 4p\n\n为了方便调整并行线程数 p，内存组织以 B[i][j] 形式的 matrix 存储。有 p 行，q = m'/p 列。我们用以下形式，表示第 t 个 pass 里的 block\n\n$$B^t[i][j],t\u003e0$$\n\nBlock 的计算规则：\n\n![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/957c983c-74e8-4a18-8b08-7f41b2856e55/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/957c983c-74e8-4a18-8b08-7f41b2856e55/Untitled.png)\n\n其中，\n\n- block index [i'][j'] 根据使用的 Argon2d 或 Argon2i 而不同，结果可能是除了当前 slice 里的其他所有 block（下面图上跨 lane 的那几个虚线）\n- G 是排列组合函数，基于 Blake2b 的 round function 改进而来\n- H' 是长度可变的、在 H 的基础上实现的哈希函数\n\n如果 t\u003e1, 我们需要重复处理过程，我们用新的 block XOR 老的 block 得出\n\n![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e425bb22-5ab5-41bb-8260-085b2d771bb8/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e425bb22-5ab5-41bb-8260-085b2d771bb8/Untitled.png)\n\n当我们完成 t 次迭代后，我们计算最终的 block B_final，为最后一列所有值的异或\n\n![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a6e327b6-1b01-47f9-97bb-772c69737134/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/a6e327b6-1b01-47f9-97bb-772c69737134/Untitled.png)\n\n最后，对 B_final 运算 H‘ 函数，完成最终的输出 Tag\n\n![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e6501409-72ff-495e-b9ee-da18d0c8e9d8/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/e6501409-72ff-495e-b9ee-da18d0c8e9d8/Untitled.png)\n\n## Features\n\n- 性能。Argon2 填充内存的速度非常快，从而增加了 AT 里的 A。Argon2i 对每个 byte 稳定占用 2 个 CPU cycles，Argon2d 就快 3 倍。\n- Tradeoff 抵御能力。默认 passes 配置下（Argon2d 为 1，Argon2i 为 3），ASIC 设备在减少至 α =1/4 或更少内存的时候，无法减少 time-area 复杂度。如果把 pass 数量提高，时间惩罚会更高。\n- 可扩展性。Argon2 可以同时在时间和内存两个维度扩展，两者互相独立，保证始终能在一定数量的时间内填满一定数量的内存。\n- 并行。Argon2 最多可以使用 2^24 个并发线程。在实验中，8 个线程就已经消耗完了所有的计算资源和带宽。\n- GPU/FPGA/ASIC-unfriendly。Argon2 对 x86 做了高度优化，所以在定制硬件下运行既不会更快也不会更便宜。\n- 支持额外的输入。除了 message 和 nonce，类似 secret key，环境变量，用户数据等内容也可以被输入作为参数\n\n## 安全性分析\n\n### Tradeoff attack\n\n结论是，data-dependent one-pass 的情况得下，攻击者可以在降低内存 3 倍的情况下，保持 time-area 复杂度不变。具体的表\n\n![https://s3-us-west-2.amazonaws.com/secure.notion-static.com/328b20be-664f-49f6-84b0-e0aae3485a3b/Untitled.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/328b20be-664f-49f6-84b0-e0aae3485a3b/Untitled.png)\n\n上面已经说过，D(α) \u003e 1/α，α 趋近于 0\n\n在论文发布后，有两次公开的对 Argon2i 的破解。作者发布了更新版本，并做了 summary\n\n- 针对 1- 和 2-pass Argon2i(v1.3) 可以减少 time-area 复杂度至 α = 1/5\n- 针对 t-pass(t\u003e2) 的 Argon2i，time-area 复杂度可以减少至 α = 1/3\n- 针对 t-pass Argon2d，time-area 复杂度可以减少至 α = 1/1.33\n\n论文里还有更多针对内存优化攻击、迭代次数压缩攻击和通用攻击的具体分析，这里不展开了\n\n更多的细节和内容去读代码和论文吧\n\n### References\n\n- [https://github.com/P-H-C/phc-winner-argon2/blob/master/argon2-specs.pdf](https://github.com/P-H-C/phc-winner-argon2/blob/master/argon2-specs.pdf)\n- [https://github.com/P-H-C/phc-winner-argon2](https://github.com/P-H-C/phc-winner-argon2)\n- [https://crackstation.net/hashing-security.htm](https://crackstation.net/hashing-security.htm)\n- [https://honest.engineering/posts/hash-functions-survival-guide](https://honest.engineering/posts/hash-functions-survival-guide?utm_source=ponyfoo+weekly\u0026utm_medium=email\u0026utm_campaign=138)\n- [https://en.wikipedia.org/wiki/Argon2](https://en.wikipedia.org/wiki/Argon2)\n- [https://en.wikipedia.org/wiki/Scrypt](https://en.wikipedia.org/wiki/Scrypt)\n"},"__N_SSG":true},"page":"/p/[filename]","query":{"filename":"argon2"},"buildId":"NneAG4sKnpsuykkV4vDeb","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/runtime/polyfills-1578adc0c195ff683a65.js"></script><script async="" data-next-page="/p/[filename]" src="/_next/static/NneAG4sKnpsuykkV4vDeb/pages/p/%5Bfilename%5D.js"></script><script async="" data-next-page="/_app" src="/_next/static/NneAG4sKnpsuykkV4vDeb/pages/_app.js"></script><script src="/_next/static/runtime/webpack-9369c5c69dbf6d4912cb.js" async=""></script><script src="/_next/static/chunks/framework.5fcc7199ef0beb206d2f.js" async=""></script><script src="/_next/static/chunks/commons.3c5d97082f0a27bb013b.js" async=""></script><script src="/_next/static/runtime/main-0fe46e94a529f955381f.js" async=""></script><script src="/_next/static/chunks/e02e1e7f.37da1e6c94fa5227f4d3.js" async=""></script><script src="/_next/static/chunks/c32e8f60042697b88c7a7eeabb52ff7d578ec089.c62b0744126db24a167b.js" async=""></script><script src="/_next/static/NneAG4sKnpsuykkV4vDeb/_buildManifest.js" async=""></script><script src="/_next/static/NneAG4sKnpsuykkV4vDeb/_ssgManifest.js" async=""></script></body></html>