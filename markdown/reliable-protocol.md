# 如何实现可靠数据传输协议
_《计算机网络》里可靠数据传输原理的笔记，笔记略精简_
## 背景知识
假设你已经知道了 IP 协议是不可靠的，如果你不知道，那你也去读一下《计算机网络》好了。
造成不可靠的原因有：__比特差错__和__丢包__
下文会按照底层协议可能出现的问题逐步复杂，最终得到一个可靠数据协议

## 只有比特差错的底层协议
简单来说，比特差错是传过来的包数据错了，没法用。

- 接收方通过__差错检测__来检查收到的包是否正确。
- 如果包正确，就发送 ACK 给发送方。如果不正确，则发送 NAK。这一步被称为__接收方反馈__。
- 发送方在收到 ACK 后才会发送下一个数据包。如果收到是 NAK 则__重传__上一个数据包。

这样的一个流程被称为自动重传请求协议（ARQ协议）。它由差错检测、接收方反馈、重传三部分组成。
因为只有完成一个数据包的传送后，才会发送下一个数据包，因此也被称为停等协议。

仔细想想，这里有一个问题，是没有考虑 ACK/NAK 受损的情况。
解决方法是发送方直接重传上一个数据包。而接受方通过看数据包中的__序号__来判断是重传还是新数据。

那既然有了序号，NAK 就可以通过发送上一个数据包的 ACK 来表示当前这个数据包没有成功。这被称为__冗余 ACK__。

总结一下比特差错的解决手段：
- 差错检验
- 重传
- 序号
- 冗余 ACK 代替 NAK

## 有比特差错和丢包的底层协议
丢包就是接收方没有收到发送方发过来的数据包。
解决方法是引入__倒计时定时器__。

发送方发出包后，启动倒计时，如果超时，重传数据包。
因为也有可能是返回的 ACK 丢包，所以**序号**还是必不可少的

总结一下丢包的解决手段：
- 重传
- 倒计时定时器
- 序号

## 更进一步
至此，一个可靠传输协议就完成了。它能够在不可靠的底层协议上实现可靠的数据传输协议（了不起）。
那他的问题是：停等协议效率太低。

解决方法是：允许发送方发送多个分组而无需等待确认，称为 pipelining。

引入的改变：
- 序号范围增加（停等协议只要01就能区分）。
- 发送发和接收方必须缓存多个分组。
- 一个具体的恢复方法；回退 N 步 / 选择重传。

### 回退 N 步
也被称为 **滑动窗口协议**。

发送方维持一个窗口。
- 假设从左往右是发送包的顺序，N 是窗口长度
- 滑动窗口最左侧是 base。代表最早未确认分组的序号
- 中间某个点是 nextseqnum，代表下一个待发送分组的序号

由此可知，
- [0, base-1] 是已确认的包
- [base, nextseqnum-1] 是发送但未确认的包
- [nextseqnum-1, N + base - 1] 是等待发送的包

一个小问题，为啥窗口有长度，发送方无限制发不好么？
因为流量控制和拥塞控制。之后如果说 TCP 协议的时候再说吧。

#### 回退 N 步如何运转
- ACK 使用**累积确认**，收到序号 n 的 ACK，表示 n 以前的包全部收到
- 只需要一个计时器
- 重传时发送方把所有已发送但未确认的包都重传
- 因为上一条，接受方在接受到乱序的包（后面包的先到了）时，直接丢弃

### 选择重传
回退 N 步的问题是一点差错就会引起大量重传

相对回退 N 步，选择重传的特点是：
- 每个包一个定时器，超时只发自己
- 接受方缓存失序的包，直到之前的包都被收到
- ACK 序号为包的序号，不是累积确认

_从原理上，我们实现了一个效率较高的可靠传输数据协议。前半段是可靠，后半段是高效_
_TCP 协议是如何实现的之后再写了👋_
