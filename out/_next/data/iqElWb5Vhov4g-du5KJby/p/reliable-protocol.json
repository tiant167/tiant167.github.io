{"pageProps":{"content":"# 如何实现可靠数据传输协议\n_《计算机网络》里可靠数据传输原理的笔记，笔记略精简_\n## 背景知识\n假设你已经知道了 IP 协议是不可靠的，如果你不知道，那你也去读一下《计算机网络》好了。\n造成不可靠的原因有：__比特差错__和__丢包__\n下文会按照底层协议可能出现的问题逐步复杂，最终得到一个可靠数据协议\n\n## 只有比特差错的底层协议\n简单来说，比特差错是传过来的包数据错了，没法用。\n\n- 接收方通过__差错检测__来检查收到的包是否正确。\n- 如果包正确，就发送 ACK 给发送方。如果不正确，则发送 NAK。这一步被称为__接收方反馈__。\n- 发送方在收到 ACK 后才会发送下一个数据包。如果收到是 NAK 则__重传__上一个数据包。\n\n这样的一个流程被称为自动重传请求协议（ARQ协议）。它由差错检测、接收方反馈、重传三部分组成。\n因为只有完成一个数据包的传送后，才会发送下一个数据包，因此也被称为停等协议。\n\n仔细想想，这里有一个问题，是没有考虑 ACK/NAK 受损的情况。\n解决方法是发送方直接重传上一个数据包。而接受方通过看数据包中的__序号__来判断是重传还是新数据。\n\n那既然有了序号，NAK 就可以通过发送上一个数据包的 ACK 来表示当前这个数据包没有成功。这被称为__冗余 ACK__。\n\n总结一下比特差错的解决手段：\n- 差错检验\n- 重传\n- 序号\n- 冗余 ACK 代替 NAK\n\n## 有比特差错和丢包的底层协议\n丢包就是接收方没有收到发送方发过来的数据包。\n解决方法是引入__倒计时定时器__。\n\n发送方发出包后，启动倒计时，如果超时，重传数据包。\n因为也有可能是返回的 ACK 丢包，所以**序号**还是必不可少的\n\n总结一下丢包的解决手段：\n- 重传\n- 倒计时定时器\n- 序号\n\n## 更进一步\n至此，一个可靠传输协议就完成了。它能够在不可靠的底层协议上实现可靠的数据传输协议（了不起）。\n那他的问题是：停等协议效率太低。\n\n解决方法是：允许发送方发送多个分组而无需等待确认，称为 pipelining。\n\n引入的改变：\n- 序号范围增加（停等协议只要01就能区分）。\n- 发送发和接收方必须缓存多个分组。\n- 一个具体的恢复方法；回退 N 步 / 选择重传。\n\n### 回退 N 步\n也被称为 **滑动窗口协议**。\n\n发送方维持一个窗口。\n- 假设从左往右是发送包的顺序，N 是窗口长度\n- 滑动窗口最左侧是 base。代表最早未确认分组的序号\n- 中间某个点是 nextseqnum，代表下一个待发送分组的序号\n\n由此可知，\n- [0, base-1] 是已确认的包\n- [base, nextseqnum-1] 是发送但未确认的包\n- [nextseqnum-1, N + base - 1] 是等待发送的包\n\n一个小问题，为啥窗口有长度，发送方无限制发不好么？\n因为流量控制和拥塞控制。之后如果说 TCP 协议的时候再说吧。\n\n#### 回退 N 步如何运转\n- ACK 使用**累积确认**，收到序号 n 的 ACK，表示 n 以前的包全部收到\n- 只需要一个计时器\n- 重传时发送方把所有已发送但未确认的包都重传\n- 因为上一条，接受方在接受到乱序的包（后面包的先到了）时，直接丢弃\n\n### 选择重传\n回退 N 步的问题是一点差错就会引起大量重传\n\n相对回退 N 步，选择重传的特点是：\n- 每个包一个定时器，超时只发自己\n- 接受方缓存失序的包，直到之前的包都被收到\n- ACK 序号为包的序号，不是累积确认\n\n_从原理上，我们实现了一个效率较高的可靠传输数据协议。前半段是可靠，后半段是高效_\n_TCP 协议是如何实现的之后再写了👋_\n"},"__N_SSG":true}