<!DOCTYPE html><html><head><meta charSet="utf-8"/><meta name="viewport" content="width=device-width"/><meta name="next-head-count" content="2"/><link rel="preload" href="/_next/static/css/65efe0fe.df0857e2.chunk.css" as="style"/><link rel="stylesheet" href="/_next/static/css/65efe0fe.df0857e2.chunk.css"/><link rel="preload" href="/_next/static/iqElWb5Vhov4g-du5KJby/pages/p/%5Bfilename%5D.js" as="script"/><link rel="preload" href="/_next/static/iqElWb5Vhov4g-du5KJby/pages/_app.js" as="script"/><link rel="preload" href="/_next/static/runtime/webpack-9369c5c69dbf6d4912cb.js" as="script"/><link rel="preload" href="/_next/static/chunks/framework.5fcc7199ef0beb206d2f.js" as="script"/><link rel="preload" href="/_next/static/chunks/commons.3c5d97082f0a27bb013b.js" as="script"/><link rel="preload" href="/_next/static/runtime/main-0fe46e94a529f955381f.js" as="script"/><link rel="preload" href="/_next/static/chunks/65efe0fe.37da1e6c94fa5227f4d3.js" as="script"/><link rel="preload" href="/_next/static/chunks/289da9abc1b241d5b4bee00ec6eb29a2c14aab85.9a2180353954e697b99c.js" as="script"/></head><body><div id="__next"><section class="ant-layout"><header class="ant-layout-header" style="position:fixed;z-index:1;width:100%"><ul style="line-height:64px" class="ant-menu ant-menu-dark ant-menu-root ant-menu-horizontal" role="menu"><li class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none" role="menuitem"><div class="ant-menu-submenu-title" role="button" aria-expanded="false" aria-haspopup="true"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li class="ant-menu-item ant-menu-item-only-child ant-menu-item-selected" role="menuitem"><a href="/">Home</a></li><li class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="display:none" role="menuitem"><div class="ant-menu-submenu-title" role="button" aria-expanded="false" aria-haspopup="true"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li><li class="ant-menu-item ant-menu-item-only-child" role="menuitem"><a href="/about/">About</a></li><li class="ant-menu-submenu ant-menu-submenu-horizontal ant-menu-overflowed-submenu" style="visibility:hidden;position:absolute" role="menuitem"><div class="ant-menu-submenu-title" role="button" aria-expanded="false" aria-haspopup="true"><span>···</span><i class="ant-menu-submenu-arrow"></i></div></li></ul></header><main class="ant-layout-content" style="padding:50px;margin-top:64px"><article class="ant-typography markdown"><h1>如何实现可靠数据传输协议</h1><p><em>《计算机网络》里可靠数据传输原理的笔记，笔记略精简</em></p><h2>背景知识</h2><p>假设你已经知道了 IP 协议是不可靠的，如果你不知道，那你也去读一下《计算机网络》好了。
造成不可靠的原因有：<strong>比特差错</strong>和<strong>丢包</strong>
下文会按照底层协议可能出现的问题逐步复杂，最终得到一个可靠数据协议</p><h2>只有比特差错的底层协议</h2><p>简单来说，比特差错是传过来的包数据错了，没法用。</p><ul><li>接收方通过<strong>差错检测</strong>来检查收到的包是否正确。</li><li>如果包正确，就发送 ACK 给发送方。如果不正确，则发送 NAK。这一步被称为<strong>接收方反馈</strong>。</li><li>发送方在收到 ACK 后才会发送下一个数据包。如果收到是 NAK 则<strong>重传</strong>上一个数据包。</li></ul><p>这样的一个流程被称为自动重传请求协议（ARQ协议）。它由差错检测、接收方反馈、重传三部分组成。
因为只有完成一个数据包的传送后，才会发送下一个数据包，因此也被称为停等协议。</p><p>仔细想想，这里有一个问题，是没有考虑 ACK/NAK 受损的情况。
解决方法是发送方直接重传上一个数据包。而接受方通过看数据包中的<strong>序号</strong>来判断是重传还是新数据。</p><p>那既然有了序号，NAK 就可以通过发送上一个数据包的 ACK 来表示当前这个数据包没有成功。这被称为<strong>冗余 ACK</strong>。</p><p>总结一下比特差错的解决手段：</p><ul><li>差错检验</li><li>重传</li><li>序号</li><li>冗余 ACK 代替 NAK</li></ul><h2>有比特差错和丢包的底层协议</h2><p>丢包就是接收方没有收到发送方发过来的数据包。
解决方法是引入<strong>倒计时定时器</strong>。</p><p>发送方发出包后，启动倒计时，如果超时，重传数据包。
因为也有可能是返回的 ACK 丢包，所以<strong>序号</strong>还是必不可少的</p><p>总结一下丢包的解决手段：</p><ul><li>重传</li><li>倒计时定时器</li><li>序号</li></ul><h2>更进一步</h2><p>至此，一个可靠传输协议就完成了。它能够在不可靠的底层协议上实现可靠的数据传输协议（了不起）。
那他的问题是：停等协议效率太低。</p><p>解决方法是：允许发送方发送多个分组而无需等待确认，称为 pipelining。</p><p>引入的改变：</p><ul><li>序号范围增加（停等协议只要01就能区分）。</li><li>发送发和接收方必须缓存多个分组。</li><li>一个具体的恢复方法；回退 N 步 / 选择重传。</li></ul><h3>回退 N 步</h3><p>也被称为 <strong>滑动窗口协议</strong>。</p><p>发送方维持一个窗口。</p><ul><li>假设从左往右是发送包的顺序，N 是窗口长度</li><li>滑动窗口最左侧是 base。代表最早未确认分组的序号</li><li>中间某个点是 nextseqnum，代表下一个待发送分组的序号</li></ul><p>由此可知，</p><ul><li><a href="">0, base-1</a> 是已确认的包</li><li><a href="">base, nextseqnum-1</a> 是发送但未确认的包</li><li><a href="">nextseqnum-1, N + base - 1</a> 是等待发送的包</li></ul><p>一个小问题，为啥窗口有长度，发送方无限制发不好么？
因为流量控制和拥塞控制。之后如果说 TCP 协议的时候再说吧。</p><h4>回退 N 步如何运转</h4><ul><li>ACK 使用<strong>累积确认</strong>，收到序号 n 的 ACK，表示 n 以前的包全部收到</li><li>只需要一个计时器</li><li>重传时发送方把所有已发送但未确认的包都重传</li><li>因为上一条，接受方在接受到乱序的包（后面包的先到了）时，直接丢弃</li></ul><h3>选择重传</h3><p>回退 N 步的问题是一点差错就会引起大量重传</p><p>相对回退 N 步，选择重传的特点是：</p><ul><li>每个包一个定时器，超时只发自己</li><li>接受方缓存失序的包，直到之前的包都被收到</li><li>ACK 序号为包的序号，不是累积确认</li></ul><p><em>从原理上，我们实现了一个效率较高的可靠传输数据协议。前半段是可靠，后半段是高效</em>
<em>TCP 协议是如何实现的之后再写了👋</em></p></article></main><footer class="ant-layout-footer" style="text-align:center">Created by <a href="https://github.com/tiant167">@tiant167</a></footer></section></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"content":"# 如何实现可靠数据传输协议\n_《计算机网络》里可靠数据传输原理的笔记，笔记略精简_\n## 背景知识\n假设你已经知道了 IP 协议是不可靠的，如果你不知道，那你也去读一下《计算机网络》好了。\n造成不可靠的原因有：__比特差错__和__丢包__\n下文会按照底层协议可能出现的问题逐步复杂，最终得到一个可靠数据协议\n\n## 只有比特差错的底层协议\n简单来说，比特差错是传过来的包数据错了，没法用。\n\n- 接收方通过__差错检测__来检查收到的包是否正确。\n- 如果包正确，就发送 ACK 给发送方。如果不正确，则发送 NAK。这一步被称为__接收方反馈__。\n- 发送方在收到 ACK 后才会发送下一个数据包。如果收到是 NAK 则__重传__上一个数据包。\n\n这样的一个流程被称为自动重传请求协议（ARQ协议）。它由差错检测、接收方反馈、重传三部分组成。\n因为只有完成一个数据包的传送后，才会发送下一个数据包，因此也被称为停等协议。\n\n仔细想想，这里有一个问题，是没有考虑 ACK/NAK 受损的情况。\n解决方法是发送方直接重传上一个数据包。而接受方通过看数据包中的__序号__来判断是重传还是新数据。\n\n那既然有了序号，NAK 就可以通过发送上一个数据包的 ACK 来表示当前这个数据包没有成功。这被称为__冗余 ACK__。\n\n总结一下比特差错的解决手段：\n- 差错检验\n- 重传\n- 序号\n- 冗余 ACK 代替 NAK\n\n## 有比特差错和丢包的底层协议\n丢包就是接收方没有收到发送方发过来的数据包。\n解决方法是引入__倒计时定时器__。\n\n发送方发出包后，启动倒计时，如果超时，重传数据包。\n因为也有可能是返回的 ACK 丢包，所以**序号**还是必不可少的\n\n总结一下丢包的解决手段：\n- 重传\n- 倒计时定时器\n- 序号\n\n## 更进一步\n至此，一个可靠传输协议就完成了。它能够在不可靠的底层协议上实现可靠的数据传输协议（了不起）。\n那他的问题是：停等协议效率太低。\n\n解决方法是：允许发送方发送多个分组而无需等待确认，称为 pipelining。\n\n引入的改变：\n- 序号范围增加（停等协议只要01就能区分）。\n- 发送发和接收方必须缓存多个分组。\n- 一个具体的恢复方法；回退 N 步 / 选择重传。\n\n### 回退 N 步\n也被称为 **滑动窗口协议**。\n\n发送方维持一个窗口。\n- 假设从左往右是发送包的顺序，N 是窗口长度\n- 滑动窗口最左侧是 base。代表最早未确认分组的序号\n- 中间某个点是 nextseqnum，代表下一个待发送分组的序号\n\n由此可知，\n- [0, base-1] 是已确认的包\n- [base, nextseqnum-1] 是发送但未确认的包\n- [nextseqnum-1, N + base - 1] 是等待发送的包\n\n一个小问题，为啥窗口有长度，发送方无限制发不好么？\n因为流量控制和拥塞控制。之后如果说 TCP 协议的时候再说吧。\n\n#### 回退 N 步如何运转\n- ACK 使用**累积确认**，收到序号 n 的 ACK，表示 n 以前的包全部收到\n- 只需要一个计时器\n- 重传时发送方把所有已发送但未确认的包都重传\n- 因为上一条，接受方在接受到乱序的包（后面包的先到了）时，直接丢弃\n\n### 选择重传\n回退 N 步的问题是一点差错就会引起大量重传\n\n相对回退 N 步，选择重传的特点是：\n- 每个包一个定时器，超时只发自己\n- 接受方缓存失序的包，直到之前的包都被收到\n- ACK 序号为包的序号，不是累积确认\n\n_从原理上，我们实现了一个效率较高的可靠传输数据协议。前半段是可靠，后半段是高效_\n_TCP 协议是如何实现的之后再写了👋_\n"},"__N_SSG":true},"page":"/p/[filename]","query":{"filename":"reliable-protocol"},"buildId":"iqElWb5Vhov4g-du5KJby","nextExport":false,"isFallback":false,"gsp":true}</script><script nomodule="" src="/_next/static/runtime/polyfills-1578adc0c195ff683a65.js"></script><script async="" data-next-page="/p/[filename]" src="/_next/static/iqElWb5Vhov4g-du5KJby/pages/p/%5Bfilename%5D.js"></script><script async="" data-next-page="/_app" src="/_next/static/iqElWb5Vhov4g-du5KJby/pages/_app.js"></script><script src="/_next/static/runtime/webpack-9369c5c69dbf6d4912cb.js" async=""></script><script src="/_next/static/chunks/framework.5fcc7199ef0beb206d2f.js" async=""></script><script src="/_next/static/chunks/commons.3c5d97082f0a27bb013b.js" async=""></script><script src="/_next/static/runtime/main-0fe46e94a529f955381f.js" async=""></script><script src="/_next/static/chunks/65efe0fe.37da1e6c94fa5227f4d3.js" async=""></script><script src="/_next/static/chunks/289da9abc1b241d5b4bee00ec6eb29a2c14aab85.9a2180353954e697b99c.js" async=""></script><script src="/_next/static/iqElWb5Vhov4g-du5KJby/_buildManifest.js" async=""></script><script src="/_next/static/iqElWb5Vhov4g-du5KJby/_ssgManifest.js" async=""></script></body></html>